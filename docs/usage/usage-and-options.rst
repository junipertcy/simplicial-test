Usage and Options
=================

*simplicial-test* implements a depth-bounded tree search algorithm, which enables a number
of techniques that may make it faster for certain input classes.

When to set :code:`cutoff`?
---------------------------

You *should* set a :code:`cutoff`, to roughly :code:`1e5` or larger,
whenever your input degree sequence has :math:`E = \sum{\textbf{d}} > 100`.

This is because that there is a only tiny fraction of simplicial input sequence
that will take a long time to determine, whereas there are a lot of hard non-simplicial inputs.
Setting a moderate :code:`cutoff` will avoid false negatives (input being simplicial, but the algorithm says not)
and waiting a long time just for a non-simplicial outcome.

When to set :code:`width`?
--------------------------

When to set :code:`depth`?
--------------------------

There is one known situation where setting :code:`depth` to a smaller number would greatly help.
That is, when :code:`degree_list` is highly skewed and :code:`size_list` is rather uniform.

Let's take :code:`degree_list = [17, 17, 16, 16, 16, 16, 16, 2, 1, 1, 1, 1]` and :code:`size_list = [3] * 40`
as an example.

This is a degree sequence generated by the (undocumented) :class:`simplicial_test.sample` module:

::

    sizes, degs, facets = gen_joint_sequence_from_sizes([3] * 40, p=0.001)

Here, you get the :code:`sizes` exactly as :code:`[3] * 40`, and with :code:`degs` sampled as some sequence, which altogether
realizes as the joint degree sequence of the :code:`facets`. *Try it.* You'll know what I mean.

If we do:

::

    st = Test([17, 17, 16, 16, 16, 16, 16, 2, 1, 1, 1, 1], [3] * 40, verbose=False, depth=1e5, width=1e5, cutoff=1e5)
    is_simplicial, facets = st.is_simplicial()

It will take a long time (depending on your :code:`cutoff`) and then tell you that it is not simplicial, which is wrong
(because it can be realized by :code:`facets`).
If you increase :code:`cutoff` to, say, :code:`1e7`, it doesn't help either.

Now let's set :code:`depth=2`,

::

    st = Test([17, 17, 16, 16, 16, 16, 16, 2, 1, 1, 1, 1], [3] * 40, verbose=False, depth=2)
    is_simplicial, found_facets = st.is_simplicial()

Voila! It takes no time.

::

    print(found_facets)
    # Out[*]:
    # ((0, 1, 8), (0, 1, 9), (0, 3, 10), (0, 2, 3), (1, 2, 6), (0, 4, 5), (3, 5, 6), (0, 2, 5), (2, 5, 6), (2, 6, 7),
    # (0, 1, 4), (0, 1, 5), (2, 3, 6), (0, 3, 6), (1, 3, 6), (4, 5, 6), (2, 4, 6), (1, 4, 6), (1, 5, 6), (1, 4, 5),
    # (0, 4, 6), (1, 2, 4), (0, 1, 2), (1, 3, 5), (0, 3, 5), (3, 4, 5), (2, 3, 5), (1, 2, 5), (0, 2, 4), (2, 3, 4),
    # (1, 3, 4), (3, 6, 7), (0, 1, 3), (0, 1, 6), (0, 1, 7), (0, 2, 6), (0, 3, 4), (2, 4, 5), (2, 3, 11), (4, 5, 12))


Other data attributes
---------------------
The main data holder is :class:`simplicial_test.utils.SimplicialDepot`.